package go_kvstore

import (
	"testing"
	"log"
)

func TestTranverse(t *testing.T) {
	tree:= NewTree(3)
	n1:=NewNode(false,3)
	n2:=NewNode(false,3)
	n3:=NewNode(true,3)
	n4:=NewNode(true,3)
	n5:=NewNode(true,3)
	n6:=NewNode(true,3)
	n7:=NewNode(true,3)
	n8:=NewNode(true,3)
	n3.Keys=[]int{1,2}
	n1.Keys=[]int{3,6}
	n4.Keys=[]int{4,5}
	n5.Keys=[]int{7,8}
	n1.Children=[]*Node{n3,n4,n5}
	
	tree.Root.Keys=[]int{9}
	tree.Root.IsLeaf=false
	n6.Keys=[]int{10,11}
	n2.Keys=[]int{12,15}
	n7.Keys=[]int{13,14}
	n8.Keys=[]int{16,17}
	n2.Children=[]*Node{n6,n7,n8}
	
	tree.Root.Children=[]*Node{n1,n2}
	
	var expectAnswer []int
	for i:=1;i<=17;i++{
		expectAnswer=append(expectAnswer,i)
	}
	
	ans:=Tranverse(tree.Root)
	if len(ans)!=len(expectAnswer){
		log.Println(ans)
		t.Fatal("lenght not equal")
	}
	
	for i:=0;i<len(ans);i++{
		if ans[i]!=expectAnswer[i]{
			log.Println(ans)
			t.Fatal("tranverse error")
		}
	}	
}

func TestInsert(t *testing.T){
	tree:=NewTree(3)
	tree.Insert(7)
	if Tranverse(tree.Root)[0]!=7{
		t.Fatal("create tree and insert first element error")
	}
	for i:=8;i<=11;i++{
		tree.Insert(i)
	}
	expectedAnswer:=make([]int,5)
	for i:=0;i<5;i++{
		expectedAnswer[i]=i+7
	}
	ans:=Tranverse(tree.Root)
	if len(ans)!=len(expectedAnswer){
		log.Println(ans)
		log.Println(expectedAnswer)
		t.Fatal("error for insert root node to full, length not equal")
	}
	for i:=range ans{
		if ans[i]!=expectedAnswer[i]{
			log.Println(ans)
			log.Println(expectedAnswer)
			t.Fatal("error for insert root node to full, element not equal")
		}
	}
	
	tree.Insert(12)
	expectedAnswer=make([]int,6)
	for i:=0;i<6;i++{
		expectedAnswer[i]=i+7
	}
	ans=Tranverse(tree.Root)
	if len(ans)!=len(expectedAnswer){
		log.Println(ans)
		log.Println(expectedAnswer)
		t.Fatal("error for first split and insert, length not equal")
	}
	for i:=range ans{
		if ans[i]!=expectedAnswer[i]{
			log.Println(ans)
			log.Println(expectedAnswer)
			t.Fatal("error for first split and insert, element not equal")
		}
	}
	
	for i:=1;i<=6;i++{
		tree.Insert(i)
	}
	expectedAnswer=make([]int,12)
	for i:=0;i<12;i++{
		expectedAnswer[i]=i+1
	}
	ans=Tranverse(tree.Root)
	if len(ans)!=len(expectedAnswer){
		log.Println(ans)
		log.Println(expectedAnswer)
		t.Fatal("error for randomly insert, length not equal")
	}
	for i:=range ans{
		if ans[i]!=expectedAnswer[i]{
			log.Println(ans)
			log.Println(expectedAnswer)
			t.Fatal("error for randomly insert, element not equal")
		}
	}
	
	for i:=19;i<=100;i++{
		tree.Insert(i)
	}
	for i:=13;i<=18;i++{
		tree.Insert(i)
	}
	expectedAnswer=make([]int,100)
	for i:=0;i<100;i++{
		expectedAnswer[i]=i+1
	}
	ans=Tranverse(tree.Root)
	if len(ans)!=len(expectedAnswer){
		log.Println(ans)
		log.Println(expectedAnswer)
		t.Fatal("error for randomly insert2, length not equal")
	}
	for i:=range ans{
		if ans[i]!=expectedAnswer[i]{
			log.Println(ans)
			log.Println(expectedAnswer)
			t.Fatal("error for randomly insert2, element not equal")
		}
	}
}

func TestFillChild(t *testing.T){
	node1:=NewNode(false,3)
	node1.Keys=[]int{3}
	node2:=NewNode(true,3)
	node2.Keys=[]int{1,2}
	node3:=NewNode(true,3)
	node3.Keys=[]int{4,5,6}
	node1.Children=[]*Node{node2,node3}
	FillChild(node1, 0)
	
	if len(node2.Keys)!=3{
		log.Println(node2.Keys)
		t.Fatal("error for filling children with borrow from right at leaf, length not right")
	}
	for i:=range node2.Keys{
		if node2.Keys[i]!=i+1{
			log.Println(node2.Keys)
			t.Fatal("error for filling children with borrow from right at leaf, wrong element")		
		}
	}
	
	FillChild(node1,1)
	if len(node3.Keys)!=3{
		log.Println(node3.Keys)
		t.Fatal("error for filling children with borrow from left at leaf, length not right")
	}
	for i:=range node3.Keys{
		if node3.Keys[i]!=i+4{
			log.Println(node3.Keys)
			t.Fatal("error for filling children with borrow from left at leaf, wrong element")		
		}
	}
	
	node3.Keys=node3.Keys[:len(node3.Keys)-1]
	mergeWithLeft:=FillChild(node1,1)
	if !mergeWithLeft{
		t.Fatal("error for filling children with merge at leaf, wrong return value")		
	}
	if len(node2.Keys)!=5{
		log.Println(node2.Keys)
		t.Fatal("error for filling children with merge at leaf, wrong length for merged child")		
	}
	for i:=range node2.Keys{
		if node2.Keys[i]!=i+1{
			log.Println(node2.Keys)
			t.Fatal("error for filling children with merge at leaf, wrong element for merged child")		
		}
	}
	if len(node1.Keys)!=0{
		log.Println(node1.Keys)
		t.Fatal("error for filling children with merge at leaf, wrong length for parent")		
	}
	
	node1=NewNode(false,3)
	node1.Keys=[]int{3}
	node2=NewNode(true,3)
	node2.Keys=[]int{1,2}
	node3=NewNode(true,3)
	node3.Keys=[]int{4,5}
	node1.Children=[]*Node{node2,node3}
	FillChild(node1, 0)
	if len(node2.Keys)!=5{
		log.Println(node2.Keys)
		t.Fatal("error for filling children with merge at leaf 2, wrong length for merged child")		
	}
	for i:=range node2.Keys{
		if node2.Keys[i]!=i+1{
			log.Println(node2.Keys)
			t.Fatal("error for filling children with merge at leaf 2, wrong element for merged child")		
		}
	}
	if len(node1.Keys)!=0{
		log.Println(node1.Keys)
		t.Fatal("error for filling children with merge at leaf 2, wrong length for parent")		
	}
	
	node1=NewNode(false,2)
	node1.Keys=[]int{4}
	
	node2=NewNode(false,2)
	node2.Keys=[]int{2}
	node3=NewNode(false,2)
	node3.Keys=[]int{6,8}
	
	node4:=NewNode(true,2)
	node4.Keys=[]int{1}
	node5:=NewNode(true,2)
	node5.Keys=[]int{3}
	
	node6:=NewNode(true,2)
	node6.Keys=[]int{5}
	node7:=NewNode(true,2)
	node7.Keys=[]int{7}
	node8:=NewNode(true,2)
	node8.Keys=[]int{9}
	
	node1.Children=[]*Node{node2,node3}
	node2.Children=[]*Node{node4,node5}
	node3.Children=[]*Node{node6,node7,node8}

	FillChild(node1, 0)
	if len(node2.Keys)!=2 || len(node2.Children)!=3{
		log.Println(node2.Keys)
		t.Fatal("error for filling children with merge at non leaf, wrong length for filled child")				
	}
	for i:=range node2.Keys{
		if node2.Keys[i]!=2*(i+1){
			log.Println(node2.Keys)
			t.Fatal("error for filling children with merge at non leaf, wrong keys for filled child")				
		}
	}
	
	for i:=range node2.Children{
		child:=node2.Children[i]
		if len(child.Keys)!=1{
			log.Println(i,child.Keys)
			t.Fatal("error for filling children with merge at non leaf, wrong key length for filled child's Children")				
		}
		if child.Keys[0]!=i*2+1{
			log.Println(i,child.Keys[0])
			t.Fatal("error for filling children with merge at non leaf, wrong keys for filled child's Children")				
		}
	}
	//TODO: maybe add more tests with nonleaf, but the test is already longer than main code
}
func TestDelete(t *testing.T){
	tree:=NewTree(3)
	for i:=1;i<=21;i++{
		tree.Insert(i)
	}
	tree.Delete(7)
	expectedAnswer:=make([]int,0)
	for i:=1;i<=21;i++{
		if i!=7{
			expectedAnswer=append(expectedAnswer,i)
		}
	}
	ans:=Tranverse(tree.Root)
	if len(ans)!=len(expectedAnswer){
		log.Println(ans)
		log.Println(expectedAnswer)
		t.Fatal("error for randomly delete, length not equal")
	}
	for i:=range ans{
		if ans[i]!=expectedAnswer[i]{
			log.Println(ans)
			log.Println(expectedAnswer)
			t.Fatal("error for randomly delete, element not equal")
		}
	}
	
	tree.Delete(21)
	expectedAnswer=expectedAnswer[:len(expectedAnswer)-1]
	ans=Tranverse(tree.Root)
	if len(ans)!=len(expectedAnswer){
		log.Println(ans)
		log.Println(expectedAnswer)
		t.Fatal("error for delete largest element, length not equal")
	}
	for i:=range ans{
		if ans[i]!=expectedAnswer[i]{
			log.Println(ans)
			log.Println(expectedAnswer)
			t.Fatal("error for delete largest element, element not equal")
		}
	}
	
	tree.Delete(1)
	expectedAnswer=expectedAnswer[1:]
	ans=Tranverse(tree.Root)
	if len(ans)!=len(expectedAnswer){
		log.Println(ans)
		log.Println(expectedAnswer)
		t.Fatal("error for delete smallest element, length not equal")
	}
	for i:=range ans{
		if ans[i]!=expectedAnswer[i]{
			log.Println(ans)
			log.Println(expectedAnswer)
			t.Fatal("error for delete smallest element, element not equal")
		}
	}
	
	tree.Insert(22)
	tree.Delete(5)
	expectedAnswer=append(expectedAnswer,22)
	i:=0
	for i<len(expectedAnswer){
		if expectedAnswer[i]==5{
			expectedAnswer=append(expectedAnswer[:i],expectedAnswer[i+1:]...)	
		}else{
			i++
		}
	}
	ans=Tranverse(tree.Root)
	if len(ans)!=len(expectedAnswer){
		log.Println(ans)
		log.Println(expectedAnswer)
		t.Fatal("error for randomly delete 2, length not equal")
	}
	for i:=range ans{
		if ans[i]!=expectedAnswer[i]{
			log.Println(ans)
			log.Println(expectedAnswer)
			t.Fatal("error for randomly delete 2, element not equal")
		}
	}
	
	for i:=range ans{
		tree.Delete(ans[i])
	}
	ans=Tranverse(tree.Root)
	if len(ans)!=0{
		t.Fatal("error for delete all elements")
	}
	
	expectedAnswer=make([]int,0)
	for i:=0;i<21;i++{
		expectedAnswer=append(expectedAnswer,i)
		tree.Insert(i)
	}
	ans=Tranverse(tree.Root)
	if len(ans)!=len(expectedAnswer){
		log.Println(ans)
		log.Println(expectedAnswer)
		t.Fatal("error for insert after delete all, length not equal")
	}
	for i:=range ans{
		if ans[i]!=expectedAnswer[i]{
			log.Println(ans)
			log.Println(expectedAnswer)
			t.Fatal("error for insert after delete all, element not equal")
		}
	}
}